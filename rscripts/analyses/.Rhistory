prob.t0 <- p
for(g in gen){
# draw from a binomial distribution with prob = to the frequency of the
# preceding generation.
freq.a <- rbinom(reps, 2*N, p)
# calculate the probability of fixing the A allele.
# 1- p would be the freq. of the a allele
p <- freq.a/ (2*N)
# fill data frame one row at a time
# Pop.size (N), generations (g), and probability (p) repeat for the number of
# iterations specified in vector "reps"
row <- data.frame(replicate = 1:reps, N = rep(N, reps),
generations = rep(g, reps),
prob.t = rep(p, reps), p = p)
#add the results of every iteration and bind them onto the same data frame by row
wfmodel.results <- rbind(wfmodel.results, row)
}
}
}
View(wfmodel.results)
library(ggplot2)
library(ggraptR)
# Create vector for population size
pop <- c(10, 100, 300, 500, 1000)
# Create vector for initial frequency of the A allele
prob <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
# create vector for number of generations to simulate
gen <- c(5, 50, 100)
# create vector for number of iterations per combination
reps <- 50
# store results
wfmodel.results <- data.frame()
for(N in pop){
for(p in prob){
#store probability in t+1 in prob.t0
prob.t0 <- p
for(g in gen){
# draw from a binomial distribution with prob = to the frequency of the
# preceding generation.
freq.a <- rbinom(reps, 2*N, p)
# calculate the probability of fixing the A allele.
# 1- p would be the freq. of the a allele
p <- freq.a/ (2*N)
# fill data frame one row at a time
# Pop.size (N), generations (g), and probability (p) repeat for the number of
# iterations specified in vector "reps"
row <- data.frame(replicate = 1:reps, N = rep(N, reps),
generations = rep(g, reps),
prob.t = rep(p, reps))
#add the results of every iteration and bind them onto the same data frame by row
wfmodel.results <- rbind(wfmodel.results, row)
}
}
}
View(wfmodel.results)
library(ggplot2)
library(ggraptR)
# Create vector for population size
pop <- c(10, 100, 300, 500, 1000)
# Create vector for initial frequency of the A allele
prob <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
# create vector for number of generations to simulate
gen <- c(5, 50, 100)
# create vector for number of iterations per combination
reps <- 50
# store results
wfmodel.results <- data.frame()
for(N in pop){
for(p in prob){
#store probability in t+1 in prob.t0
prob.t0 <- p
for(g in gen){
# draw from a binomial distribution with prob = to the frequency of the
# preceding generation.
freq.a <- rbinom(reps, 2*N, p)
# calculate the probability of fixing the A allele.
# 1- p would be the freq. of the a allele
p <- freq.a/ (2*N)
# fill data frame one row at a time
# Pop.size (N), generations (g), and probability (p) repeat for the number of
# iterations specified in vector "reps"
row <- data.frame(replicate = 1:reps, N = rep(N, reps),
generations = rep(g, reps),
prob.t1 = rep(p, reps), probt0 = p)
#add the results of every iteration and bind them onto the same data frame by row
wfmodel.results <- rbind(wfmodel.results, row)
}
}
}
View(wfmodel.results)
result <- mean(rbinom(5, 10, 0.05))
result <- mean(rbinom(10, 5 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
result <- mean(rbinom(10, 5, 0.05))
library(ggplot2)
library(ggraptR)
# Create vector for population size
pop <- c(10, 100, 300, 500, 1000)
# Create vector for initial frequency of the A allele
prob <- c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
# create vector for number of generations to simulate
gen <- c(5, 50, 100)
# create vector for number of iterations per combination
reps <- 50
# store results
wfmodel.results <- data.frame()
for(N in pop){
for(p in prob){
#store probability in t+1 in prob.t0
prob.t0 <- p
for(g in gen){
# draw from a binomial distribution with prob = to the frequency of the
# preceding generation.
freq.a <- rbinom(reps, 2*N, p)
# calculate the probability of fixing the A allele.
# 1- p would be the freq. of the a allele
p <- freq.a/ (2*N)
# fill data frame one row at a time
# Pop.size (N), generations (g), and probability (p) repeat for the number of
# iterations specified in vector "reps"
row <- data.frame(replicate = 1:reps, N = rep(N, reps),
generations = rep(g, reps),
prob.t1 = rep(p, reps), p = p)
#add the results of every iteration and bind them onto the same data frame by row
wfmodel.results <- rbind(wfmodel.results, row)
}
}
}
View(row)
View(wfmodel.results)
View(wfmodel.results)
install.packages(c("backports", "BiocManager", "callr", "curl", "data.table", "DescTools", "devtools", "digest", "ellipsis", "gdtools", "htmltools", "htmlwidgets", "KernSmooth", "later", "maptools", "mgcv", "pkgbuild", "pkgconfig", "promises", "rmarkdown", "shiny", "xfun"))
install.packages(c("boot", "data.table", "foreign", "KernSmooth", "mgcv", "nlme"))
R.version
install.packages("ape",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("caper",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("diversitree",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("geiger",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("nlme",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("OUwie",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("phangorn",repos="https://cloud.r-project.org",quiet=TRUE)
install.packages("phytools",repos="https://cloud.r-project.org",quiet=TRUE)
packageVersion("ape")
library(tidyr)
detach("package:tidyr", unload = TRUE)
library(tidyr)
detach("package:tidyr", unload = TRUE)
library(ape)
set.seed(1)
tree <- rcoal(5)
str(tree)
# where topology is stored in R
tree$edge
#S4 methods for plotting specific data structures using a given package.
plot(tree, show.tip.label = F)
nodelabels()
tiplabels()
# elements in the matrix now make sense. Which node is only present in the first column but not in the
# second column, this determines which is the root node.
# every row, the first element is the first node, connecting a second node or tip.
tree$edge
# describes the length of each branch
tree$edge.length
# plot with different colours
cols <- c(rep("black", 4), rep("red", 4))
plot(tree, edge.color = cols, edge.width = 2)
plot(tree, edge.color = cols, edge.width = 2, show.tip.label = F)
shapes <- c(rep(8, 2), rep(2, 3))
# or use offset = .01 to move the character tips
tiplabels(pch=shapes, col = "blue", adj = .51)
# tiplabels(pch=shapes, col= "blue", adj = .01)
nodelabels(pch=c(NA, 16,  16, 21), cex = 1, bg= c(NA, "black", "black", "white"))
nodelabels(text = c("", .89, .91, .45), frame = "none", adj=c(1.3, -.7), cex = .8)
tree <- rcoal(1000)
plot(tree, show.tip.label = F)
si <- sample(c("Y", "N"), 1000, replace = T)
perc.self <- runif(1000)
perc.self[si == "Y"] <- 0
my.dat <- data.frame(tree$tip.label, si, perc.self)
#shuffling to educational purposes
my.dat  <- my.dat[sample(1:1000), ]
# check the order of the first item on the tree&tip.label[1], and my.dat$tree.tip.label[1]
# we need to match these.
ordered.dat <- as.data.frame(matrix(, 0, 3))
for(i in 1:1000){
hit <- which(my.dat$tree.tip.label == tree$tip.label[i])
ordered.dat[i, 1] <- as.character(my.dat[hit, 1])
ordered.dat[i, 2:3] <- my.dat[hit, 2:3]
}
View(ordered.dat)
View(my.dat)
colnames(ordered.dat) <- c("tree.tip.label", "si", "perc.self")
View(ordered.dat)
View(ordered.dat)
View(ordered.dat)
c("red", "blue")[ordered.dat$si]
plot(tree, show.tip.label = F)
plot(tree, show.tip.label = F, type = "f")
# create vector of colours using the factors in "si"
# same approach can be applied to using characters instead of colours
tip.cols <- c("red", "blue")[ordered.dat$si]
tiplabels(col= tip.cols, pch = 15)
plot(tree, show.tip.label = F, type = "f")
tiplabels(col= tip.cols, pch = 15, cex = .1)
tiplabels(col= tip.cols, pch = 15, cex = .1)
plot(tree, show.tip.label = F, type = "f")
tiplabels(col= tip.cols, pch = 15, cex = .4, offset = .1)
plot(tree, show.tip.label = F, type = "f")
tiplabels(col= tip.cols, pch = 15, cex = .2, offset = .001)
plot(tree, show.tip.label = F, type = "f")
tiplabels(col= tip.cols, pch = 15, cex = .2, offset = .01)
library(geiger)
library(phytools)
# simulate a bd tree in geiger
tree <- sim.bdtree(b= ,3, d= .1, n= 50)
plot(tree)
# simulate a bd tree in geiger
tree <- sim.bdtree(b= ,3, d= .1, n= 50, extinct = F)
plot(tree)
tree <- drop.extinct(tree)
plot(tree)
# simulate a discrete trait
# Vertical side on the markov matrix is what you are in right now, you pick probabilities of
# transitioning to the state on the horizontal of the matrix.
# markov matrices are routinely called 'q'
q <- rbind(c(-1, .1),
c(.4, -.4))
View(q)
colnames(q) <- c("R", "S")
View(q)
sus.trait <- sim.char(phy= tree, par= q, model="discrete", root= 1)
sus.trait <- sim.char(phy= tree, par=q, model="discrete", root= 1)
# simulate a bd tree in geiger
tree <- sim.bdtree(b= ,3, d= .1, n= 50)
tree <- drop.extinct(tree)
plot(tree)
# simulate a discrete trait
# Vertical side on the markov matrix is what you are in right now, you pick probabilities of
# transitioning to the state on the horizontal of the matrix.
# markov matrices are routinely called 'q'
q <- rbind(c(-1, .1),
c(.4, -.4))
colnames(q) <- c("R", "S")
sus.trait <- sim.char(phy= tree, par=q, model="discrete", root= 1)
# simulate a discrete trait
# Vertical side on the markov matrix is what you are in right now, you pick probabilities of
# transitioning to the state on the horizontal of the matrix.
# markov matrices are routinely called 'q'
q <- rbind(c(-1, .1),
c(.4, -.4))
sus.trait <- sim.char(phy= tree, par=q, model="discrete", root= 1)
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
library(geiger)
library(phytools)
# simulate a bd tree in geiger
tree <- sim.bdtree(b= ,3, d= .1, n= 50)
tree <- drop.extinct(tree)
plot(tree)
# simulate a discrete trait
# Vertical side on the markov matrix is what you are in right now, you pick probabilities of
# transitioning to the state on the horizontal of the matrix.
# markov matrices are routinely called 'q'
q <- rbind(c(-1, .1),
c(.4, -.4))
View(q)
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
sus.trait<-sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
# simulate a discrete trait
# Vertical side on the markov matrix is what you are in right now, you pick probabilities of
# transitioning to the state on the horizontal of the matrix.
# markov matrices are routinely called 'q'
q <- rbind(c(-.1, .1),
c(.4, -.4))
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
sus.trait
# simulate a continuous trait (expression level of a gene for example)
exp.trait <- sim.char(phy=tree, par=.3, model="BM", root=5)
# infer the history of a discrete trait. Allows us to estimate the rate of a given transition
map <- make.simmap(tree=tree, x=sus.trait)
#if left at default, it assumes the root of the tree, or initial state has equal probability.
# if you use a prior then it changes this.
map.2 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2))
# allow rate to change. i.e. all transition rates can be different.
map.3 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2), model="ARD")
plotSimmap(map.3)
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=2)[,,1]
# infer the history of a discrete trait. Allows us to estimate the rate of a given transition
map <- make.simmap(tree=tree, x=sus.trait)
#if left at default, it assumes the root of the tree, or initial state has equal probability.
# if you use a prior then it changes this.
map.2 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2))
# allow rate to change. i.e. all transition rates can be different.
map.3 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2), model="ARD")
plotSimmap(map.3)
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=2)[,,1]
# infer the history of a discrete trait. Allows us to estimate the rate of a given transition
map <- make.simmap(tree=tree, x=sus.trait)
#if left at default, it assumes the root of the tree, or initial state has equal probability.
# if you use a prior then it changes this.
map.2 <- make.simmap(tree=tree, x=sus.trait, pi=c(1, 0))
# allow rate to change. i.e. all transition rates can be different.
map.3 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2), model="ARD")
plotSimmap(map.3)
sus.trait <- sim.char(phy=tree, par=q, model="discrete", root=1)[,,1]
# simulate a continuous trait (expression level of a gene for example)
exp.trait <- sim.char(phy=tree, par=.3, model="BM", root=5)
# infer the history of a discrete trait. Allows us to estimate the rate of a given transition
map <- make.simmap(tree=tree, x=sus.trait)
#if left at default, it assumes the root of the tree, or initial state has equal probability.
# if you use a prior then it changes this.
map.2 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2))
# allow rate to change. i.e. all transition rates can be different.
map.3 <- make.simmap(tree=tree, x=sus.trait, pi=c(0, 2), model="ARD")
plotSimmap(map.3)
# simulate a continuous trait (expression level of a gene for example)
exp.trait <- sim.char(phy=tree, par=.3, model="BM", root=5)[,,1]
# infer the history of a continuous trait
contMap(tree=tree, x=exp.trait)
# infer the history of a continuous trait
contMap(tree=tree, x=exp.trait, type = "fan")
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
data.frame(exp.trait, row.names = names(exp.trait))
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
foo <- as.matrix(data.frame(exp.trait, row.names = names(exp.trait)))
pred <- as.factor(sus.trait)
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
resp <- as.matrix(data.frame(exp.trait, row.names = names(exp.trait)))
pred <- as.factor(sus.trait)
fit <- aov.phylo(pred~resp, tree, nsim=1000)
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
resp <- as.matrix(data.frame(exp.trait, row.names = names(exp.trait)))
pred <- as.factor(sus.trait)
fit <- aov.phylo(pred~resp, tree, nsim=1000)
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
resp <- matrix(exp.trait, 50, 1)
# anova on phylo. using a variance/covariance matrix (or simulate regular anova 1000 times to generate
#F statistic 1000 times to compare against the continuous trait, the continuous trait is the predictor
# the discrete trait is the response)
resp <- matrix(exp.trait, 50, 1)
row.names(resp) <- names(exp.trait)
pred <- as.factor(sus.trait)
fit <- aov.phylo(resp~pred, tree, nsim=1000)
install.packages("learnPopGen")
library(learnPopGen)
?learnPopGen
??learnPopGen
pop.fem <- vector(length = 3)
names(pop.fem) <- c("00", "01", "11")
pop.mal <- vector(length = 3)
names(pop.mal) <- c("00", "01", "11")
pop.fem[1:3] <- floor(females/3)
pop.mal[1:3] <- floor(males/3)
names(pop.mal) <- c("00", "01", "11")
pop.mal
source("../functions/functions.esd.R")
setwd("~/Julio's PhD projects Dropbox/Julio Gamboa/sex.bias/rscripts/analyses")
source("../functions/functions.esd.R")
GetInitialPop <- function(females, males)
# sets up initial genomes
GetInitialPop <- function(females, males){
# females = number of females in the population
# males = number of males in the population
# create a vector for female genotypes
pop.fem <- vector(length = 3)
names(pop.fem) <- c("00", "01", "11")
# create a vector for male genotypes
pop.mal <- vector(length = 3)
names(pop.mal) <- c("00", "01", "11")
# determine the largest value that can go into
# each of the possible genotypes
pop.fem[1:3] <- floor(females/3)
pop.mal[1:3] <- floor(males/3)
# determine any "leftover" individuals when
# we try to split the popsize into genotypes
extra.fem <- females%%3
extra.mal <- males%%3
# add in those "leftover" individuals to
# genotypes randomly
if(extra.fem==1){
pick <- sample(1:3, 1)
pop.fem[pick] <- pop.fem[pick] + 1
}
if(extra.fem==2){
pick <- sample(1:3, 2)
pop.fem[pick] <- pop.fem[pick] + 1
}
if(extra.mal==1){
pick <- sample(1:3, 1)
pop.mal[pick] <- pop.mal[pick] + 1
}
if(extra.mal==2){
pick <- sample(1:3, 2)
pop.mal[pick] <- pop.mal[pick] + 1
}
result <- c(pop.fem[1:2], 0, pop.fem[3],
pop.mal[1:2], 0, pop.mal[3])
return(result)
}
View(GetInitialPop)
population <- rep(0, 8)
names(population) <- c("fem.11", "fem.12", "fem.21", "fem.22",
"mal.11", "mal.12", "mal.21", "mal.22")
return(population)
if(h==0){
fit <- c(1,   1+s,   1+s,   1+s,
1+s, 1, 1, 1)
return(fit)
}
if(h==.5){
fit <- c(1, 1+h*s, 1+h*s, 1+s,
1+s,   1+h*s, 1+h*s, 1)
return(fit)
}
h <- 0
if(h==0){
fit <- c(1,   1+s,   1+s,   1+s,
1+s, 1, 1, 1)
return(fit)
}
s = 0.5
if(h==0){
fit <- c(1,   1+s,   1+s,   1+s,
1+s, 1, 1, 1)
return(fit)
}
names(population) <- c("fem.11", "fem.12", "fem.21", "fem.22",
"mal.11", "mal.12", "mal.21", "mal.22")
if(h==0){
fit <- c(1,   1+s,   1+s,   1+s,
1+s, 1, 1, 1)
return(fit)
}
fit <- c(1,   1+s,   1+s,   1+s,
1+s, 1, 1, 1)
x.mom <- c(rep(1, pop[1]), rep(2, pop[2]), rep(3, pop[3]), rep(4, pop[4]))
x.dad <- c(rep(5, pop[5]), rep(6, pop[6]), rep(7, pop[7]), rep(8, pop[8]))
# create a vector for female genotypes
pop.fem <- vector(length = 3)
names(pop.fem) <- c("00", "01", "11")
# create a vector for male genotypes
pop.mal <- vector(length = 3)
names(pop.mal) <- c("00", "01", "11")
# determine the largest value that can go into
# each of the possible genotypes
pop.fem[1:3] <- floor(females/3)
# here we calculate number of males and females in the pop
females <- comm.sex[i]
comm.sex <- 100
osr <- 0.2
# determine the largest value that can go into
# each of the possible genotypes
pop.fem[1:3] <- floor(females/3)
# here we calculate number of males and females in the pop
females <- comm.sex[i]
females <- comm.sex
males <- round(comm.sex*osr)
# determine the largest value that can go into
# each of the possible genotypes
pop.fem[1:3] <- floor(females/3)
pop.mal[1:3] <- floor(males/3)
# determine any "leftover" individuals when
# we try to split the popsize into genotypes
extra.fem <- females%%3
extra.mal <- males%%3
pick <- sample(1:3, 1)
pop.fem[pick] <- pop.fem[pick] + 1
# add in those "leftover" individuals to
# genotypes randomly
if(extra.fem==1){
pick <- sample(1:3, 1)
pop.fem[pick] <- pop.fem[pick] + 1
}
# add in those "leftover" individuals to
# genotypes randomly
if(extra.fem==1){
pick <- sample(1:3, 1)
pop.fem[pick] <- pop.fem[pick] + 1
}
# determine the largest value that can go into
# each of the possible genotypes
pop.fem[1:3] <- floor(females/3)
# add in those "leftover" individuals to
# genotypes randomly
if(extra.fem==1){
pick <- sample(1:3, 1)
pop.fem[pick] <- pop.fem[pick] + 1
}
if(extra.mal==1){
pick <- sample(1:3, 1)
pop.mal[pick] <- pop.mal[pick] + 1
}
if(extra.mal==2){
pick <- sample(1:3, 2)
pop.mal[pick] <- pop.mal[pick] + 1
}
