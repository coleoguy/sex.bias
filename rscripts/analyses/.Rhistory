names(population) <- c("fem.X1X1", "fem.X1X2", "fem.X2X1", "fem.X2X2",
"mal.X1Y1", "mal.X1Y2", "mal.X2Y1", "mal.X2Y2")
return(population)
}
measureFit <- function(pop, h, s){
if(h!=99){
fit <- c(1,   1+h*s,   1+h*s,   1+s,
1, 1/(1+h*s), 1/(1+h*s), 1/(1+s))
return(fit)
}
if(h==99){
fit <- c(1, 1+s, 1+s, 1+s,
1+s, 1+s, 1+s, 1)
return(fit)
}
}
GetParentsGeno <- function(pop, fit, females, males){
x.mom <- c(rep(1, pop[1]), rep(2, pop[2]), rep(3, pop[3]), rep(4, pop[4]))
x.dad <- c(rep(5, pop[5]), rep(6, pop[6]), rep(7, pop[7]), rep(8, pop[8]))
fit.mom <- c(rep(fit[1], pop[1]), rep(fit[2], pop[2]),
rep(fit[3], pop[3]), rep(fit[4], pop[4]))
fit.dad <- c(rep(fit[5], pop[5]), rep(fit[6], pop[6]),
rep(fit[7], pop[7]), rep(fit[8], pop[8]))
# this effectively performs viability selection
# so we sample females as moms based on fitness
mom.genomes <- sample(x = x.mom,
size = females,
replace = T,
prob=fit.mom)
# THIS IS WHERE THE PROBLEM IS WE ARE SAMPLING BASED ON FITNESS BUT EQUAL
# NUMBERS OF EACH then we sample males as dads based on fitness
dad.genomes <- sample(x.dad,
size = males,
replace = T,
prob=fit.dad)
# we can simplify our coding a bit by taking into consideration that
# there are 4 genotypes of moms and 4 genotypes of dads lets make a
# table that allows us to draw sperm and eggs based on the genotype
# distribution of parents and we will account for recombination in
# this step as well.
mom.geno <- rep(0, 4)
names(mom.geno) <- c("X1X1", "X1X2", "X2X1", "X2X2")
mom.geno[1] <- sum(mom.genomes==1)
mom.geno[2] <- sum(mom.genomes==2)
mom.geno[3] <- sum(mom.genomes==3)
mom.geno[4] <- sum(mom.genomes==4)
dad.geno <- rep(0, 4)
names(dad.geno) <- c("X1Y1", "X1Y2", "X2Y1", "X2Y2")
dad.geno[1] <- sum(dad.genomes==5)
dad.geno[2] <- sum(dad.genomes==6)
dad.geno[3] <- sum(dad.genomes==7)
dad.geno[4] <- sum(dad.genomes==8)
parents <- list(mom.geno, dad.geno)
names(parents) <- c("moms", "dads")
return(parents)
}
makeEggs <- function(mom.geno){
eggs <- rep(0, 2)
names(eggs) <- c("X1", "X2")
eggs[1] <- mom.geno[1] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
eggs[2] <- mom.geno[4] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
return(eggs)
}
makeSperm <- function(dad.geno, rd){
sperm <- rep(0, 4)
names(sperm) <- c("X1", "X2", "Y1", "Y2")
sperm[1] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
sperm[2] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[3] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[4] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
return(sperm)
}
makeNewPop <- function(pop, eggs, sperm, females, males){
x  <-  paste(sample(1:2, size = females, replace=T, prob = eggs),
sample(1:2, size = females, replace=T, prob = sperm[1:2]))
pop[1] <- sum(x == "1 1")
pop[2] <- sum(x == "1 2")
pop[3] <- sum(x == "2 1")
pop[4] <- sum(x == "2 2")
x <- paste(sample(1:2, size = males, replace=T, prob = eggs),
sample(1:2, size = males, replace=T, prob = sperm[3:4]))
pop[5] <- sum(x == "1 1")
pop[6] <- sum(x == "1 2")
pop[7] <- sum(x == "2 1")
pop[8] <- sum(x == "2 2")
return(pop)
}
Generation <- function(pop, females, males, rd, h, s){
fit <- measureFit(pop, h, s)
parents <- GetParentsGeno(pop, fit, females, males)
eggs <- makeEggs(parents$moms)
sperm <- makeSperm(parents$dads, rd)
pop <- makeNewPop(pop, eggs, sperm, females, males)
return(pop)
}
GetFreq <- function(pop, chrom, allele, males, females){
ones <- twos <- 0
if(chrom == "Y"){
if(allele == 1) ones <- (pop[5] + pop[7]) / males
if(allele == 2) twos <- (pop[6] + pop[8]) / males
}
if(chrom == "A"){
ones <- (pop[1]*2 + pop[2] + pop[3] +
pop[5]*2 + pop[6] + pop[7]) / (2 * sum(pop))
twos <- 1 - ones
}
if(chrom == "X"){
if(allele == 1){
ones <- (pop[1] * 2 + pop[2] + pop[3] + pop[5] + pop[6]) /
(males + females * 2)
}
if(allele == 2){
twos <- (pop[4] * 2 + pop[2] + pop[3] + pop[7] + pop[8]) /
(males + females * 2)
}
}
if(allele == 1) return(ones)
if(allele == 2) return(twos)
}
results.XY <- matrix(NA,1000,8)
for(i in 1:1000){
results.XY[i, 1:8] <- Generation(pop, s=.5, h=.5, rd=.5, females, males)
}
plot(desnity(results[,8]))
plot(density(results[,8]))
lines(density(results.XY[,8]))
plot(density(results[,7]))
lines(density(results.XY[,7]))
results.XY <- matrix(NA,10000,8)
for(i in 1:10000){
results.XY[i, 1:8] <- Generation(pop, s=.5, h=.5, rd=.5, females, males)
}
source("../functions/functions.esd.R")
results <- matrix(NA,10000,8)
for(i in 1:10000){
results[i, 1:8] <- Generation(pop, s=.5, h=.5, females, males)
}
plot(density(results[,6]))
lines(density(results.XY[,6]))
plot(density(results[,7]))
lines(density(results.XY[,7]))
help(density)
plot(density(results[,7],bw=.5))
plot(density(results[,7],bw=.5))
lines(density(results.XY[,7],bw=.5))
plot(density(results[,6],bw=.5))
lines(density(results.XY[,6],bw=.5))
plot(density(results[,5],bw=.5))
lines(density(results.XY[,5],bw=.5))
plot(density(results[,4],bw=.5))
lines(density(results.XY[,4],bw=.5))
plot(density(results[,8],bw=.5))
lines(density(results.XY[,8],bw=.5))
plot(density(results[,4]))
lines(density(results.XY[,4]))
plot(density(results[,3]))
lines(density(results.XY[,3]))
plot(density(results[,2]))
lines(density(results.XY[,2]))
plot(density(results[,1]))
lines(density(results.XY[,1]))
#For ESD
results <- matrix(NA,10000,8)
for(i in 1:10000){
results[i, 1:8] <- Generation(pop, s=.95, h=.5, females, males)
}
# For XY
results.XY <- matrix(NA,10000,8)
for(i in 1:10000){
results.XY[i, 1:8] <- Generation(pop, s=.95, h=.5, rd=.5, females, males)
}
# Julio Rincones Gamboa
# jgamboa@bio.tamu.edu
# j.a.r.gamboa@gmail.com
# P.I. Dr. Heath Blackmon
# coleoguy@gmail.com
# simulating populations with sex bias
# and sexual antagonism
makeGenomes <- function(females, males, freqs=NULL){
population <- rep(0, 8)
if(!is.null(freqs)){
population <- freqs
}else{
print("supply frequencies")
}
names(population) <- c("fem.X1X1", "fem.X1X2", "fem.X2X1", "fem.X2X2",
"mal.X1Y1", "mal.X1Y2", "mal.X2Y1", "mal.X2Y2")
return(population)
}
measureFit <- function(pop, h, s){
if(h!=99){
fit <- c(1,   1+h*s,   1+h*s,   1+s,
1, 1/(1+h*s), 1/(1+h*s), 1/(1+s))
return(fit)
}
if(h==99){
fit <- c(1, 1+s, 1+s, 1+s,
1+s, 1+s, 1+s, 1)
return(fit)
}
}
GetParentsGeno <- function(pop, fit, females, males){
x.mom <- c(rep(1, pop[1]), rep(2, pop[2]), rep(3, pop[3]), rep(4, pop[4]))
x.dad <- c(rep(5, pop[5]), rep(6, pop[6]), rep(7, pop[7]), rep(8, pop[8]))
fit.mom <- c(rep(fit[1], pop[1]), rep(fit[2], pop[2]),
rep(fit[3], pop[3]), rep(fit[4], pop[4]))
fit.dad <- c(rep(fit[5], pop[5]), rep(fit[6], pop[6]),
rep(fit[7], pop[7]), rep(fit[8], pop[8]))
# this effectively performs viability selection
# so we sample females as moms based on fitness
mom.genomes <- sample(x = x.mom,
size = females,
replace = T,
prob=fit.mom)
# THIS IS WHERE THE PROBLEM IS WE ARE SAMPLING BASED ON FITNESS BUT EQUAL
# NUMBERS OF EACH then we sample males as dads based on fitness
dad.genomes <- sample(x.dad,
size = males,
replace = T,
prob=fit.dad)
# we can simplify our coding a bit by taking into consideration that
# there are 4 genotypes of moms and 4 genotypes of dads lets make a
# table that allows us to draw sperm and eggs based on the genotype
# distribution of parents and we will account for recombination in
# this step as well.
mom.geno <- rep(0, 4)
names(mom.geno) <- c("X1X1", "X1X2", "X2X1", "X2X2")
mom.geno[1] <- sum(mom.genomes==1)
mom.geno[2] <- sum(mom.genomes==2)
mom.geno[3] <- sum(mom.genomes==3)
mom.geno[4] <- sum(mom.genomes==4)
dad.geno <- rep(0, 4)
names(dad.geno) <- c("X1Y1", "X1Y2", "X2Y1", "X2Y2")
dad.geno[1] <- sum(dad.genomes==5)
dad.geno[2] <- sum(dad.genomes==6)
dad.geno[3] <- sum(dad.genomes==7)
dad.geno[4] <- sum(dad.genomes==8)
parents <- list(mom.geno, dad.geno)
names(parents) <- c("moms", "dads")
return(parents)
}
makeEggs <- function(mom.geno){
eggs <- rep(0, 2)
names(eggs) <- c("X1", "X2")
eggs[1] <- mom.geno[1] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
eggs[2] <- mom.geno[4] +
0.5 * mom.geno[2] +
0.5 * mom.geno[3]
return(eggs)
}
makeSperm <- function(dad.geno, rd){
sperm <- rep(0, 4)
names(sperm) <- c("X1", "X2", "Y1", "Y2")
sperm[1] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
sperm[2] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[3] <- 0.5 * dad.geno[1] +
0.5 * dad.geno[2] * rd +
0.5 * dad.geno[3] * (1 - rd)
sperm[4] <- 0.5 * dad.geno[4] +
0.5 * dad.geno[2] * (1 - rd)  +
0.5 * dad.geno[3] * rd
return(sperm)
}
makeNewPop <- function(pop, eggs, sperm, females, males){
x  <-  paste(sample(1:2, size = females, replace=T, prob = eggs),
sample(1:2, size = females, replace=T, prob = sperm[1:2]))
pop[1] <- sum(x == "1 1")
pop[2] <- sum(x == "1 2")
pop[3] <- sum(x == "2 1")
pop[4] <- sum(x == "2 2")
x <- paste(sample(1:2, size = males, replace=T, prob = eggs),
sample(1:2, size = males, replace=T, prob = sperm[3:4]))
pop[5] <- sum(x == "1 1")
pop[6] <- sum(x == "1 2")
pop[7] <- sum(x == "2 1")
pop[8] <- sum(x == "2 2")
return(pop)
}
Generation <- function(pop, females, males, rd, h, s){
fit <- measureFit(pop, h, s)
parents <- GetParentsGeno(pop, fit, females, males)
eggs <- makeEggs(parents$moms)
sperm <- makeSperm(parents$dads, rd)
pop <- makeNewPop(pop, eggs, sperm, females, males)
return(pop)
}
GetFreq <- function(pop, chrom, allele, males, females){
ones <- twos <- 0
if(chrom == "Y"){
if(allele == 1) ones <- (pop[5] + pop[7]) / males
if(allele == 2) twos <- (pop[6] + pop[8]) / males
}
if(chrom == "A"){
ones <- (pop[1]*2 + pop[2] + pop[3] +
pop[5]*2 + pop[6] + pop[7]) / (2 * sum(pop))
twos <- 1 - ones
}
if(chrom == "X"){
if(allele == 1){
ones <- (pop[1] * 2 + pop[2] + pop[3] + pop[5] + pop[6]) /
(males + females * 2)
}
if(allele == 2){
twos <- (pop[4] * 2 + pop[2] + pop[3] + pop[7] + pop[8]) /
(males + females * 2)
}
}
if(allele == 1) return(ones)
if(allele == 2) return(twos)
}
results.XY <- matrix(NA,10000,8)
for(i in 1:10000){
results.XY[i, 1:8] <- Generation(pop, s=.95, h=.5, rd=.5, females, males)
}
plot(density(results[,1]))
lines(density(results.XY[,1]))
plot(density(results[,8]))
lines(density(results.XY[,8]))
# first we load our functions
source("../functions/functions.R")
# here we set up all the variables that we will explore in our
# simulations below
# numbers of females
females <- c(50, 100, 500, 1000)
# levels of bias to explore
bias <- c(.8,.6,.4,.2,.1,.05)
# recombination distance
rd <- c(0, .1, .2, .5)
# dominance factor of allele 1
h <- c(0, .5, 1, 99) # 99 indicates to run SSD model
# selection strengths
s <- c(.1,.2,.5,.9)
# number of trials to run
iter <- 1000
# this allows the program to be run on multiple CPUs
library(doMC)
registerDoMC(7)
# these are used mainly for trouble shooting
# normally these are iterated in the loops below
ii<- i <- j <- k <- m <- 1
results <- list()
for(i in 1:length(females)){
results[[i]] <- list()
names(results)[i] <- paste("females", females[i], sep = "")[1]
for(ii in 1:length(bias)){
results[[i]][[ii]] <- list()
names(results[[i]])[ii] <- paste("males", bias[ii], sep = "")[1]
for(j in 1:length(rd)){
results[[i]][[ii]][[j]] <- list()
names(results[[i]][[ii]])[j] <- paste("rd", rd[j], sep = "")
for(k in 1:length(h)){
results[[i]][[ii]][[j]][[k]] <- list()
names(results[[i]][[ii]][[j]])[k] <- paste("h", h[k], sep = "")
for(m in 1:length(s)){
results[[i]][[ii]][[j]][[k]][[m]] <- list()
names(results[[i]][[ii]][[j]][[k]])[m] <- paste("s", s[m], sep = "")
}
}
}
}
}
females
i <- 3
bias
ii <- 6
length(rd)
rd
j <- 4
k <- 2
m <- 3
cat("running pop size:", females[i], "\n")
cat("running bias:", bias[ii], "\n")
cat("running rd:", rd[j], "\n")
cat("running h:", h[k], "\n")
cat("running s:", s[m], "\n")
run.result <- matrix(,iter,3)
colnames(run.result) <- c("X", "Y", "A")
x <- foreach(n=1:iter, .combine = "rbind") %dopar%{
# these next two lines handle figuring out how many males
# we have based on female count and current bias level
males.each <- round(females[i]*bias[ii]/4)
males <- males.each*4
# here we make the initial population with all equal
# frequencies of each genotype in males and females
pop <- makeGenomes(females, males,
freqs = c(rep(females[i]/4, 4),
rep(males.each, 4)))
# this sets up the contain for a given sim
resultY <- resultX <- resultA <- c()
# this will be true unless an allele has fixed as the SAL
segregating <- T
# this is just a counter
p <- 1
# this while loop will run till something fixes or
# until we reach 2000 generations
while(segregating){
print(p)
# this gets the allele frequencies we are interested in
resultA[p] <- GetFreq(pop, chrom="A", allele = 1,
females=females[i], males=males)
resultY[p] <- GetFreq(pop, chrom="Y", allele = 1,
females=females[i], males=males)
resultX[p] <- GetFreq(pop, chrom="X", allele = 2,
females=females[i], males=males)
# this runs a generation of the simulation
pop <- Generation(pop, females=females[i], males=males,
rd=rd[j], h=h[k], s=s[m])
# this checks to see if something is fixed in the pop
if(resultY[p] %in% c(1,0) & resultX[p] %in% c(1,0)){
segregating <- F
A <- resultA[p]
X <- resultX[p]
Y <- resultY[p]
}
# this checks to see if we have run 2000 generations
if(p > 500){
segregating <- F
A <- resultA[p]
X <- resultX[p]
Y <- resultY[p]
}
# this increments our counter
p <- p + 1
}
# this puts the final result of our sim together
c(X, Y, A)
}
View(x)
hist(x[,3])
library(doMC)
source("../functions/functions.esd.R")
# repeat
comm.sex <- c(1000, 500, 100, 50)
osr <- c(1, .8, .6, .4, .2, .1,.05)
s <- c(0.1, 0.2, 0.5, 0.9)
h <- c(0.0, 0.5, 1.0)
replicates <- 1000
max.gens <- 1500
results <- as.data.frame(matrix(NA,replicates,6))
colnames(results) <- c("freq0", "OSR", "sex.com", "num.com", "h", "s")
i <- 3
print(paste("working on common sex =", comm.sex[i]))
i <- 2
print(paste("working on common sex =", comm.sex[i]))
osr
j <- 8
# here we calculate number of males and females in the pop
females <- comm.sex[i]
males <- round(comm.sex[i]*osr[j])
comm.sex[i]
osr[j]
j <- 7
osr[j]
males <- round(comm.sex[i]*osr[j])
# here we calculate the total number of chromosomes
chroms <- 2 * males + 2 * females
s
k <- 3
h<-2
h <- c(0.0, 0.5, 1.0)
m <- 2
# how many cores to run on
registerDoMC(6)
source("../functions/functions.esd.R")
library(doMC)
# how many cores to run on
registerDoMC(6)
x <- foreach (iter = 1:replicates, .combine = "c") %dopar% {
# sets up the initial population
pop <- GetInitialPop(females, males)
fre <- GetFreq(pop,allele=0,males,females)
# this flag and counter will allow us to break out of the
# while loop if an allele fixes or we have run as long
# as we want to allow it to run
segregating <- T
counter <- 1
while(segregating){
# one generation of selection
pop <- Generation(pop, s=s[k], h=h[m], females, males)
# calculate the frequency of 0 allele
old.fre <- fre
fre <- GetFreq(pop, allele=0, males, females)
# test whether we have met stopping conditions
if(fre == 0 | fre == 1 | counter == max.gens ){
#|round(old.fre, digits=5) == round(fre, digits=5)
#THIS CODE HAS BEEN PULLED FOR TROUBLESHOOTING WAS ADDES AS POTENTIAL SPEED INCREASE BUT
# COULD BE TERMINATING WHEN DO TO DRIFT YOU HAPPEN TO HAVE LITTLE CHANGE IN ONE GEN.
segregating <- F
}
counter <- counter + 1
}
fre
}
hist(x)
